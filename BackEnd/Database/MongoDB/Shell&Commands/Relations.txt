Relations:
----------
When relating a collection to another collection there are 2 ways to represent a relation:
1. Embedded documents
2. Refrences

1. Embedded documents:
----------------------
    - We represent a collection within a collection
    - EX: Within a customer we have an embedded document which represents the products of this customer 
    - ADV: You don't have to query multiple documents to get the desired output
    - DISAVD: can lead to redundant or duplicate data in a collection
    - EX: if 2 customers bought the same product there will be a duplicate entry for that product in both the customer documents
        - Solution is refrences.

2. Refrences:
-------------
    - We represent a relation between collections using a fk.
    - That foreign key is usually the _id of the other relation
    - EX: Within customer we have a purchases fields but only contains the ids of products purchased related to the customer not the actual products document.
          The products details are in their own seprate relation however here customer is refrencing products collection using the _id of the products documents. 
    - ADV: Less or no redundant data 
    - DISADV: We need to query multiple collections to get the desired result. 
        - EX: To get the name of a product that a customer purchases, we have to query customer to get the purchases id and then query product table to get product name using that product id. 
    
    
USE CASES WHICH WAY TO USE?
---------------------------
    ONE TO ONE RELATION => EMBEDDED DOCUMENT:
    -----------------------------------------
        -  We represent the relation as a nested document, In here we can choose either collections to have the other one as a nested document in it.
        -  EX: we can store a users contact information as a nested document in user.
        -  EX: db.collection_name.insertOne({name:"omar", contact:{email:'test@gmail.com, phone:'01929373673'} })
    
    ONE TO ONE RELATION => REFRENCES:
    -------------------------------------
        - We do this when we know when we are intresed in the fields of a specific collection more than the other 
        - Example: if i have address document inside users, If im only intrested in the address fields then i don't need to fetch all the user related data. 
                   Another way is that if i'm only intrested in the user data but not the address then no need to fetch the address part when querying the users. 
        - In such prefrences we use refrences to link between the data. 

    Querying Multiple Documents(joining) from related collections $lookup&aggregate:
    ------------------------------------------------------------
        - From the above example, assume im using refrences. User collection and address collection and in user their is an address_id field which refrences an id in the address collection.
        - So to show case the related address documents to the user (using joins)
        - db.<collection1>.aggregate([
            {
                $lookup: {
                from: "<collection2>",
                localField: "<field_in_collection1>",
                foreignField: "<field_in_collection2>",
                as: "<output_field_name>"
                }
            }
            ])
            - collection1: The collection where you're starting the query from (this collection contains the reference).
            - from: "<collection2>": The collection you're joining with collection1.
            - localField: "<field_in_collection1>": The field in collection1 that stores the reference (the "joining key").
            - foreignField: "<field_in_collection2>": The field in collection2 that matches the value in localField (the key to join on).
            - as: "<output_field_name>": The name of the field in the result where the merged data from collection2 will be stored.

        -EX: db.customer.aggergate([$lookup: {from:"address",localField:"address_id", foreignField: "_id",as:"addr"}])
        - In the result i get the user details&fields with the joined address details under a field called addr.
    
    ONE TO MANY RELATION => EMBEDDED DOCUMENT:
    ------------------------------------------
        - Same as one to one but we do this when ensuring that the size of the main document doesn't exceed 16MB. 
        - We can use embedded document when we know having such case will not exceed that size
        - Example: With customer and payment method aka adding card details.  a user wont have many payment methods so its acceptable. 

    ONE TO MANY RELATION => REFRENCES:
    ------------------------------------------
        - Here is when we know that that a document having a nested document will cause an overload or the entire document will be large in data size. 
        - ExampleL Customer with orders, we can refrence the order id and in a seprate relation have the order details. 
    
    MANY TO MANY RELATION => REFRENCES:
    ------------------------------------------
        - EX: Orders collection and a products collection : an order can have many products and a product can belong to many orders.
        - It is not advised to use embedded documents in a many-to-many relation. 
            - Redundant or duplicate data, if any thing changes, it needs to be updated in multiple places
        - Instead we use refrences
        - We do it like the ONE TO MANY using refrences we add a refrence key in one of the collections based on criteria and then we can join
        - In our example, we will have pids as a refrence key in orders. 
