Overview of async and await:
- async and await are used in JavaScript to handle asynchronous operations, simplifying the code by making it more readable and easier to work with than using raw promises or callback functions. 
- They are built on top of Promises but allow you to write asynchronous code in a way that looks synchronous.

What is an async function?
--------------------------
    - An async function is a function that always returns a Promise. Even if you explicitly return a non-promise value, it will automatically be wrapped in a resolved Promise.
    - the return value in an async function = the resolve value in a promise
    - if i want to add a reject value in an async function then i throw a new error. 
    - Basicaaly async functions are a simpler way of creating promises.
    - I can later then call/await that async function in another async function. 

What is await?
---------------
    - await is used to wait for a Promise to settle (resolve or reject). When you place await in front of a promise, only the async function 
    that is awaiting the other function  pauses at that point,  waits for the promise to resolve or reject, and then resumes with the resolved value or error.
    - The Promise that await pauses for can be the result of another async function or any function that returns a Promise.
    - Meanwhile, the main thread of your application continues running, so other code can execute in parallel.
    - because the function you're await-ing is a Promise. Promises run asynchronously, meaning they allow the rest of your application to continue executing while waiting for the time-consuming operation to complete.
    - await can only be used inside an async function.
    - The function is paused at the await expression until the Promise is resolved.
    - If the promise is rejected, it throws an error that can be caught by a try...catch block.

    - The reason await can only be used inside an async function is because async functions are specifically designed to work with Promises, 
    - and await is a keyword that pauses the execution of an async function until a Promise is resolved or rejected.

Explanation of async/await and try-catch:
-----------------------------------------
    - await is used to pause the execution of an async function until the promise either resolves (success) or rejects (failure).
    - The function must be marked as async in order to use await. The async keyword ensures that the function will always return a promis
    - Success Scenario:
        - If the promise resolves successfully, the code after await continues to execute and the value returned by the promise (in the try block) is assigned to the variable
    - Error Scenario:
        - when the promise is rejected or an error is thrown, the error is passed to the catch block and execution of the async function stops with a rejection reason of that await error.  
        - In the catch block,  The error is handled in the catch block, preventing your application from crashing. 
        - you can access that error using the variable (commonly named error) that represents the reason the promise was rejected or the error that was thrown.

Breakdown:
----------
    - async:
        - The async keyword before the function means the function will return a promise. Inside the function, you can use await to handle promises synchronously.
    - await:
        - await has to be called in an async function
        - await pauses the execution of the function until the promise resolves or rejects.
        - If the promise resolves, it returns the resolved value usually assigned to a variable.
        - If the promise rejects, it throws an error, which is caught by the catch block.
    - Example:
        async function getData() {
            const result = await fetchData();  // Pauses until fetchData() resolves
            console.log(result);  // Logs the resolved value of the promise
        }

    -  When you have an async function, and inside it you use await to call another Promise-based function, 
    - if that inner await throws an error (i.e., the Promise it waits on rejects), the entire async function will reject with that error.


Calling async function:
-----------------------
    - Scenario 1: Calling an async Function with await:
        - When you call an async function with await, the execution of the code pauses until the promise returned by the async function is resolved or rejected. 
        - If the promise is resolved, the value returned by the promise is stored in the variable assigned to it.
        - If the promise is rejected, the control passes to the catch block (if using try-catch). 
        - This allows you to handle the resolved value directly without needing to use .then().
        - The function where you're using await must be marked as async.
    - Scenario 2: Calling an async Function Without await:
        - When you call an async function without await, the function still returns a promise, but the rest of the code does not wait for the promise to resolve.
        - This is useful when you want to run multiple asynchronous operations concurrently or when you don't need to wait for the async function's result.
        - Without await, the async function runs, but the caller doesn't wait for its result.
        - You use await when you want to pause the execution of a function until the Promise resolves (or rejects). 
        - If you do not need to wait for the result and are okay with the Promise running in the background, you can call the function normally without await.
        -  If you are not using await when calling an async function, the function runs asynchronously in the background, 
        -  and any errors that occur inside the async function will be handled within the function itself (if there is a try/catch inside the async function).
        - so when calling it from the top of the pyramid for it to run in the background(aka calling the function with no await) i dont need to surround it with try and catch as any nested promise /async function is handled using try and catch. 
            (Check last example= run() and asyncrun() and callmakerequest()).
    - Error handling tip:
        - When you have a chain of async functions calling each other, you can propagate any errors that occur in the lower-level functions (by re-throwing them) up the chain to the last async function, where you can handle them in a try/catch block.


Calling async controller function in express routes:
----------------------------------------------------
    - In Express.js, when you define a route and pass an async controller function to handle requests, you do not need to use await in the route itself. 
    - The reason for that is that i dont want the rest of my application to stp waiting for one request to be executed.
    - Just like the last example in the code, what happens is that the async controllor function runs in the background while the rest of my app is executing
    - i don't need to wait for it to finish executing the controllor function as that will stop my application temporarily which is defenitly not advised
    - instead im letting my controllor function run in the background and once it resolves it returns my reponse at any time and if it fails then it is handled within the controllor
      function itself within the try and catch. 
    - if that controllor function is awaiting a promise within it, as the entire function is running on the background then only that controllor function waits(pauses) until the nested promise to resolve / reject
      but since im not waiting for my actual controllor function to finish so that should not have any impact on my application. 
      once my nested promise resolves in the controllor function, then the controllor function returns a response to the client at any given time, while the rest of my main thread and app has been executing.
    - Key Points:
        - You only need to make the controller function async if you're using await within it.
        - In the route definition, simply pass the async controller without using await. Express will wait for the controller's Promise to resolve or reject automatically.
        - Express will handle the async function's return value (which is a Promise) as it waits for the function to complete before sending the response.